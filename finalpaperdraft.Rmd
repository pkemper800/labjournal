---
title: "finalpaperdraft"
author: "Paige Kemper"
date: "2025-10-26"
output: html_document
---

```{r, globalsettings, echo=FALSE, warning=FALSE, results='hide'}
library(knitr)

knitr::opts_chunk$set(echo = TRUE)
opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test2"))
options(width = 100)
rgl::setupKnitr()


colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }


```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```

Last compiled on `r format(Sys.time(), '%B, %Y')`

<br>


Code for SNA Final Paper: Draft 



----



# Data Prep Work 

## Clear data
```{r}
rm(list=ls()) #start clean
```


## Load Functions + Packages
```{r}
library(readxl)
library(selenider)
library(rvest)
library(tidyverse)
library(netstat)
library(pingr)
library(jsonlite)
library(stringr)
library(openalexR)


packages <- c("tidyverse", "scholar", "openalexR", "rvest", "jsonlite")
packages <- c("devtools", "igraph")

fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

fsave <- function(x, file = NULL, location = "./data/processed/") {
    ifelse(!dir.exists("data"), dir.create("data"), FALSE)
    ifelse(!dir.exists("data/processed"), dir.create("data/processed"), FALSE)
    if (is.null(file))
        file = deparse(substitute(x))
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, file, "_", datename, ".rda", sep = "")
    save(x, file = totalname)  #need to fix if file is reloaded as input name, not as x. 
}

fload <- function(filename) {
    load(filename)
    get(ls()[ls() != "filename"])
}

fshowdf <- function(x, ...) {
    knitr::kable(x, digits = 2, "html", ...) %>%
        kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>%
        kableExtra::scroll_box(width = "100%", height = "300px")
}

```


## Access large data file of professors (the set of egos for research)

### Load Dataset 
```{r}
scholars <- fload("C:/Github/labjournal/20251017scholars.Rda") 
```


### Isolate RU from RUG (rename Groningen Uni) 
This will make it easier to isolate Radboud, to run analysis on only Radboud before scaling to all universities in the Netherlands.
```{r}
scholars$demographics = scholars$demographics |>
  mutate(
    universiteit.22 = str_replace(universiteit.22, 'RUG', "UvG"),
    universiteit.24 = str_replace(universiteit.24, 'RUG', "UvG"),
    universiteit.25 = str_replace(universiteit.25, 'RUG', "UvG")
)
```



## New fcolnet function

### Define Network Data Helper Function
Note: Includes all other universities (and 'NA') + both sociology AND political science disciplines, so function will be able to first apply to Radboud AND scale to include all other universities. 
```{r}
fcolnet = function(data = scholars, university = c("RU", 'UU', 'VU', 'UvA', 'UvG', 'UvT', 'Leiden', 'EUR', 'NA'), discipline = c('Sociologie', 'Politicologie'), waves = list(c(2015,
    2018), c(2019, 2023), c(2024, 2025)), type = c("first")) {

    university = paste0('(', paste0(university, collapse='|' ), ')')
    discipline = paste0('(', paste0(discipline, collapse='|' ), ')')

    # step 1
    demographics = data$demographics
    sample = which(
        (str_detect(demographics$universiteit.22, university)
            | str_detect(demographics$universiteit.24, university)
            | str_detect(demographics$universiteit.25, university)
        ) & (
            str_detect(demographics$discipline.22, discipline)
            | str_detect(demographics$discipline.24, discipline)
            | str_detect(demographics$discipline.25, discipline)
        ) |> replace_na(FALSE))

    demographics_soc = demographics[sample, ] |> drop_na(id)

    # step 2
    ids = demographics_soc$id |> unique()


    scholars_sel = list() 
    for (id_ in ids){
        scholars_sel[[id_]] = bind_rows(scholars$works) |>
            filter(author_id == id_)
    }
    scholars_sel = bind_rows(scholars$works) 
    

    nwaves = length(waves)
    nets = array(0, dim = c(nwaves, length(ids), length(ids)), dimnames = list(wave = 1:nwaves, ids,
        ids))
    dimnames(nets)

    # step 3
    df_works = tibble(
            works_id = scholars_sel$id, 
            works_author = scholars_sel$authorships, 
            works_year = scholars_sel$publication_year
        )


    df_works = df_works[!duplicated(df_works), ]

    # step 4
    if (type == "first") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = df_works_w$works_author[i][[1]]$id[1]
                alters = df_works_w$works_author[i][[1]]$id[-1]
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }

    if (type == "last") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                ego = rev(df_works_w$works_author[i][[1]]$id[1])
                alters = rev(df_works_w$works_author[i][[1]]$id[-1])
                if (sum(ids %in% ego) > 0 & sum(ids %in% alters) > 0) {
                  nets[j, which(ids %in% ego), which(ids %in% alters)] = 1
                }
            }
        }
    }
    if (type == "all") {
        for (j in 1:length(waves)) {
            df_works_w = df_works[df_works$works_year >= waves[[j]][1] & df_works$works_year <= waves[[j]][2],
                ]
            for (i in 1:nrow(df_works_w)) {
                egos = df_works_w$works_author[i][[1]]$id
                if (sum(ids %in% egos) > 0) {
                  nets[j, which(ids %in% egos), which(ids %in% egos)] = 1
                }
            }
            diag(nets[j,,]) = 0
        }
    }

    output = list()
    output$data = demographics_soc
    output$nets = nets
    return(output)
}
```

This includes three waves of data, waves separated per the time they were pulled. For my analysis, I will only focus on the first two waves, since the third wave covers a smaller time period and may inadvertently distort results. 

In the future, it would be more ideal to include and confirm this analysis on a third wave of data, ideally with a similar time frame and/or analysis that would account for the difference in time frames. I do not try to redistribute the years of the waves because that would be quite complicated, and using the first two waves of the data should address the research questions as is.


### load Rsiena packages
Loading additional packages necessary for analysis of data. 
```{r}
packages = c(
    "RSiena", "tidyverse",
    'dplyr', 'stringr' # these packages were added to make the code run
)
fpackage.check(packages)

```



----



# Radboud Data

## Getting Data for Radboud 
Application: I will create an adjacency matrix ('test') with the subset of professors from Radboud University, as well as a data frame with the ego-level characteristics I will be investigating. 

### Load Data
```{r}
# Radboud only (where I want to start)
test = fcolnet(scholars, 
               university = c("RU"), #only Radboud 
               discipline = c("Sociologie", "Politicologie"),
               type = c("first")) #directed 
df_ego = bind_rows(test$data)
```

This establishes the dataframes for preliminary analysis.  I will first try analysis of this subset from the "scholars" database with just professors from Radboud University, before then scaling analysis to all the universities. Notably, this database already includes both sociology and political science disciplines (departments for each respective university). I will analyze gender in collaborations, though it will be important later to control for the discipline. 

Additionally, this will look at the social network of collaboration patterns as directed, assuming that the first author initiates a collaboration. EXPLAIN WHY DIRECTED: 

Ideally the analysis would also expand to controlling for university level differences, though in this research I was not able to do this. 

### Wrangle Data
NOTE: POTENTIALLY EXCLUDE WAVE 3!! <- COME BACK TO THIS***
Separate data waves (from when the data was pulled) to better analyze the evolution over time. 

```{r}
wave1 = test$nets[1,,]
wave2 = test$nets[2,,]
wave3 = test$nets[3,,] # code currently includes wave 3, however this wave is not included in my analysis (my analysis prioritizes waves 1 and 2). 

nets = array(
    data = c(wave1, wave2), # NOTE TO SELF: REMOVED WAVE 3 FROM 'NETS' 
    dim = c(dim(wave2), 2)
)

net = sienaDependent(nets)
```


## Isolate Key Variables

### Isolate Gender variable (binary)
Make sure to include binary variable for gender, as gender is the independent variable that is analyzed in this research. With this, male = 0, and female = 1. Female is 1 because I hypothesize that women are more likely to collaborate. 

It is important to acknowledge that gender is an ego-level characteristic. COME BACK TO THIS TO EXPLAIN. 

```{r}
# Recoding for gender
df_ego = df_ego |>
    mutate(
        female = case_when(
            gender == "female" ~ 1,
            gender == "male" ~ 0,
            .default = NA 
        )
    )

female = coCovar(df_ego$female) #CREATE GENDER CO VARIABLE
```


### Isolate disicipline variable (binary, used for control)
I want to be able to control for the department, so I will create an additional binary variable denoting if the ego/professor is affiliated with sociology (0) or political science (1). This will serve as a constant covariate, looking at EgoX effect per discipline. Political science is 1 because literature found that political science departments at Dutch universities tend to have less balanced gender distribution than sociology, and I hypothesize that as a result, women will be more likely to participate in cross-gender collaborations, as it may be more important for their credibility and opportunity for promotion.  

Ideally, I would also control for each university. 

```{r}
# Recoding for discipline, must include all three waves because authors scraped from most recent wave need to be accounted for. Latest discipline is the discipline that the professor is associated with (we assume that the discipline does not change).
df_ego = df_ego |>
    mutate(
        polsci = case_when(
            discipline.22 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.22 == "Sociologie" ~ 0,
            discipline.24 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.24 == "Sociologie" ~ 0,
            discipline.25 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.25 == "Sociologie" ~ 0,
            .default = NA
        )
    )

polsci = coCovar(df_ego$polsci) #CREATE DISCIPLINE CO VAR
```




----

## Preliminary Descriptives - Variables

### Distribution of Gender (Female = 1) Overall 
```{r}
summary(df_ego$female)
```
The distribution of gender appears relatively balanced, with a mean of 0.5091, indicating slightly more women as professors, though remaining very close to .50, it is reasonable to assume that gender is equally distributed among professors at Radboud. 


### Distribution of Discipline (Political Science = 1)
```{r}
summary(df_ego$polsci)
```
The distribution of discipline appears close to .5, with a mean of 0.4955, indicating slightly more sociology professors than political science professors. However, as the means remaining close to .50, it is reasonable to assume that discipline is also equally distributed among professors at Radboud. 


### Distribution of Gender by Discipline 
```{r}
table(df_ego$gender, df_ego$discipline.24, useNA = "ifany")
```
While there is near 50% proportion of men and women, and a near 50% proportion of political science and sociology professors, there is the chance that one discipline has imbalanced gender representation. Therefore, it is important to check. I do so by creating a simple table to check, as demonstrated. This shows that there are a few more female than male political science professors, though a near 50% proportion of men and women sociology professors. I then visualize this in the bar graph below. I used discipline counts from 2024 as the latest wave from the data I studied. 


### Plot Distribution of Gender by Discipline
```{r}
library(ggplot2)

df_ego %>%
  filter(!is.na(gender) & !is.na(discipline.24)) %>%
  ggplot(aes(x = discipline.24, fill = gender)) +
  geom_bar(position = "dodge") +
  labs(title = "Gender Distribution by Discipline",
       x = "Discipline", 
       y = "Count") +
  theme_minimal()
```



----



## Network Descriptives 

### Visualizing Networks - Radboud University Wave 1

#### Make adjacency matrix for first wave of RU data
```{r}
# make adjacency matrix with first wave of data
test_wave1ru <- igraph::graph_from_adjacency_matrix(
  test$nets[1,,], #for this example I take the first wave of data. (thus I select the array of networks and take the first matrix)
  mode = c("directed"), # directed from the first author
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NULL
)

test_wave1ru
```


#### RU Wave 1 - First plot of data (colored: women represented with red and men represented with blue)
```{r}
# changing V: Letâ€™s make size proportional to betweenness score
# V(test_wave1ru)$size = betweenness(test_wave1ru, normalized = T, directed = TRUE) * 100 + 20  #after some trial and error

#plot to see if it worked 
plot(test_wave1ru,
  vertex.color = ifelse(df_ego$female == 1, "red", "blue"),
  vertex.label = NA,
  edge.width = 0.2,
  vertex.size = sqrt(igraph::degree(test_wave1ru))*3 + 5,
  edge.arrow.size =0.2)

dim(test_wave1ru) #check it works 
sum(is.na(test_wave1ru)) #check it is complete -- if 0 missing values


# how do I plot only the collaborations? 
# test_wave1ru_collabs <- 

```


### Visualizing Networks - Radboud University Wave 2

#### Make adjacency matrix for second wave of RU data
```{r}
test_wave2ru <- igraph::graph_from_adjacency_matrix(
  test$nets[2,,], #for this example I take the first wave of data. (thus I select the array of networks and take the first matrix)
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NULL
)
```


#### RU Wave 2 - First plot of data (colored: women represented with red and men represented with blue)
```{r}
#V(test_wave2ru)$size = betweenness(test_wave2ru, normalized = T, directed = TRUE) * 100 + 8  #after some trial and error

#plot to see if it worked 
plot(test_wave2ru,
  vertex.color = ifelse(df_ego$female == 1, "red", "blue"),
  vertex.label = NA,
  edge.width = 0.2,
  vertex.size = sqrt(igraph::degree(test_wave2ru))*3 + 5,
  edge.arrow.size =0.2)
```



## Descriptive Statistics 
### Degrees - Radboud Professors 
Next, it is important to look at measures of centrality. The number of degrees of connections is the simplest term for centrality. If there are differences in degree centrality, then we can illustrate nodes by differing size (for example) to accommodate for this. This is demonstrated in the wave 1 and wave 2 network visualizations of radboud political science and sociology professors collaboration networks, as the professors that participate in more collaborations (shared publications) have a larger node size.  

With the descriptive statistics, we want to describe if this network is complete, the size of this network, what kind of relationships there are (whether or not it is directed), and the node type (as well as if the tie is weighted). We will also briefly look at local and global transitivity, looking at both the dyads and triads that form in this collaboration network for reference. Considering this is not a big part of the research questions though, we will not focus on this in the analysis. 


### Load Packages
```{r}
library(igraph)
require(igraph)

packages <- c("tidyverse", "scholar", "openalexR", "rvest", "jsonlite")
packages <- c("devtools", "igraph")
```


### Size 
```{r}
#SIZE
# number of nodes for RU professors - both sociology and political science 
vcount(test_wave1ru) #returns 111
vcount(test_wave2ru) #returns 111
```
There are 111 nodes in both wave 1 and wave 2 of this network, representing 111 professors in the Radboud University social network data.


### Edges
```{r}
#EDGES
# number of edges for RU professors
ecount(test_wave1ru) #returns 31
ecount(test_wave2ru) #returns 85
```
There are 31 edges in wave 1, and 85 edges in wave 2, representing collaborations/shared publications in the Radboud University social network data.


### In-Degree Clustering and Spread
```{r}
#DEGREE
# looking at clustering and spread
igraph::degree(test_wave1ru)
igraph::degree(test_wave2ru)


hist(table(degree(test_wave1ru)), xlab='indegree', main= 'Histogram of indegree') 
# every number is the degree level of each actor. We can see it is heavily skewed to the left. 
# Wave 1: see frequency of 7 for indegree 0:20, frequency of 0 for indegree 20:80, frequency 1 for indegree 100:150

hist(table(degree(test_wave2ru)), xlab='indegree', main= 'Histogram of indegree') 
# Similarly, we can see that wave 2 is also heavily left skewed.  
# Wave 2: see frequency of 8 for indegree 0:10, frequency of 2 for indegree 10:20, 0 for 20:50, 1 for 50:60. 
```
While we can see with the above histograms that there is left-skewed indegree distributions, indicating that the vast majority of egos collaborate between 0-1 times, the nuance of the distribution is unclear. We therefore will further inspect degree centrality for each wave. 


### Degree Centrality Wave 1
```{r}
#degree centrality w1 
degree_w1 <- degree(test_wave1ru)
degree_w1 <- as.data.frame(degree_w1)

# view(degree_w1)
ggplot(degree_w1, aes(as.numeric(degree_w1), colour = as.numeric(degree_w1) )) +
  geom_histogram(binwidth = .5) +
  labs(
    title = "Distribution Degrees Wave 1",
    x = "Distribution of Degrees",
    y = "Count"
  )  +
  ylim(0, 150) +
  theme_bw()
```
With this histogram, we can better see the distribution of collaborations, with most professors having 0 degrees, several having 1 degree, and then only a few professors having 2 or more degrees, with the maximum number of degrees at 7 in wave 1 for Radboud University. Looking at summary statistics of degree distribution for wave 1, the mean degrees is 0.5586. 

```{r}
summary(degree_w1)
```



### Degree Centrality Wave 2
```{r}
#degree centrality w2 
degree_w2 <- degree(test_wave2ru)
degree_w2 <- as.data.frame(degree_w2)
ggplot(degree_w2, aes(as.numeric(degree_w2), colour = as.numeric(degree_w2))) +
  geom_histogram(binwidth = .5) +
  labs(
    title = "Distribution Degrees Wave 2",
    x = "Distribution of Degrees",
    y = "Count"
  ) +
  ylim(0, 150) +
  theme_bw()
```
With this second histogram, we can also see the distribution of collaborations and how it shifted since wave 1. Most professors still have 0 degrees, though notably less professors have 0 degrees than in wave 1, which makes sense considering the professors have had more time to publish. Similarly, we can also see relatively more professors having between 1-4 degrees. From there, only a few professors have 5 or more degrees, with the maximum number of degrees at 15. Looking at summary statistics of the degree distribution, the average degrees of wave 2 is 1.532, nearly 1 entire degree higher than in wave 1. 

```{r}
summary(degree_w2)
```



### Transitivity - come back to
Note: Transitivity is not a main focus for this research, as we focus on the effect of gender in collaborations rather than XXX.
```{r}
#TRANSITIVITY -- all of these return "NAN" -- check?
#ALSO: DIRECTED/UNDIRECTED FOR DATA?

# directed: be aware that directed graphs are considered as undirected. CHECK IF TEST_W1 AND 2 ARE DIRECTED OR UNDIRECTED.
## FLAG - ERROR WITH THIS - NOT ABLE TO REALLY USE/VIEW RESULTS
igraph::transitivity(test_wave1ru, type = c("localundirected"), isolates = c("NaN", "zero")) #differences pop out less 
igraph::transitivity(test_wave2ru, type = c("localundirected"), isolates = c("NaN", "zero")) #differences pop out less 

hist(table(transitivity(test_wave1ru, type = c("localundirected"), isolates = c("NaN", "zero"))))
hist(table(transitivity(test_wave2ru, type = c("localundirected"), isolates = c("NaN", "zero"))))


#BETWEENNESS
# directed: be aware that directed graphs are considered as undirected. CHECK IF TEST_W1 AND 2 ARE DIRECTED OR UNDIRECTED.
igraph::transitivity(test_wave1ru, type = c("localundirected"), isolates = c("NaN", "zero"))
igraph::transitivity(test_wave2ru, type = c("localundirected"), isolates = c("NaN", "zero"))

```



### Dyad and Triad Census (for ref.)
Moving from local to global transitivity, we next look at triads for global transitivity. Global transitivity refers to the number of observed over the possible transitive triads. We can identify all transitive triads that have taken place, and then all possible triads. For this, we will first review dyads, still looking at dyads as directed considering that the network is assumed to be directed as initiated by the first author.

```{r}
igraph::dyad_census(test_wave1ru) #with plot -- works 
  # Returns: 4 mut, 23 asym, 6078 null 
igraph::dyad_census(test_wave2ru) #with plot -- works
  # Returns: 7 mut, 71 asym, 6027 null
```
The dyad census for wave 1 returns 4 mutual, 23 asymmetrical, and 6078 null collaborations. The dyad census for wave 2 returns 7 mutual, 71 asymmetrical, 6027 null collaborations. This is intuitive, as it is reasonable that the total number of collaborations would increase from wave 1 to wave 2, and that the total mutual collaborations in particular would increase, as authors who have collaborated before may be more comfortable with future partnerships (in reference to theoretical foundations/literature. COME BACK TO THIS.)



### Triad census, transitivity and triad allegation (for ref.)
We next review triads, assuming that they are undirected for simplicity, as this is for reference, in order to contextualize findings. 
We will briefly look at triad census, transitivity, and triad allegation for reference. While this is not essential to research, it is interesting to consider in the context of collaboration networks, and understanding the collaboration patterns at work. 

**Triad Census**
```{r}
igraph::triad_census(test_wave1ru) #with plot -- works
  # Returns:  [1] 218926   2422    416     10     14      8      9      6      1      0      1      0      0      1      1      0

igraph::triad_census(test_wave2ru) #with plot -- works
  # Returns:   [1] 213567   7306    709     25    106     41     34      6     10      1      0      1      4      2      2      1

```
The triad census generally demonstrates that from wave 1 to wave to, the proportion of collaborations generally increase across the board. This supports the theoretical assumptions that people who have collaborated before are likely to collaborate again, and are likely to collaborate with other egos that they are familiar with (or that their previous collaborators have collaborated with).


**Transitivity and Triad Allegation**
```{r}
library(sna)

# Wave 1
sna::triad.census(test$nets[1,,]) #with adj matrix of test_wave1ru -- triad.census of (test_w1) doesn't work. 
unloadNamespace("sna")  #detach this package again to avoid interference with other igraph functions 
  # Returns:         003  012  102   021D 021U 021C 111D 111U 030T 030C 201 120D 120U 120C 210 300
           # [1,] 218926 2422  416   10   14    8    9    6    1    0   1    0    0    1   1   0
  # Same as igraph triad census! 


igraph::transitivity(test_wave1ru, type = "global") #with plot
  # Returns: [1] 0.1578947
sna::gtrans(test$nets[1,,]) #triad census a different way, but this is with plot - need with adj mat:
  # Returns: [1] 0.1515152

triad_w1ru <- data.frame(sna::triad.census(test$nets[1,,])) #save as df, #with adj matrix
transitivity_w1 <- (3 * triad_w1ru$X300)/(triad_w1ru$X201 + 3 * triad_w1ru$X300) #X300 is variable for transitive triad (the fully closed triad) - we multiply by 3 because there are 3 possible transitive triads
transitivity_w1
  # Returns 0 (?)


# Wave 2
sna::triad.census(test$nets[2,,])
unloadNamespace("sna")  #I will detach this package again
   # Returns: 003    012   102   021D  021U  021C  111D  111U  030T  030C 201  120D  120U 120C  210  300
      # [1,] 213567  7306  709   25    106   41    34     6    10    1    0    1     4    2     2    1


triad_w2ru <- data.frame(sna::triad.census(test$nets[2,,])) #save as df

igraph::transitivity(test_wave2ru, type = "global")
  # Returns: [1] 0.2290909
sna::gtrans(test$nets[2,,]) #triad census a different way 
  # Returns: [1] 0.2741935


transitivity_w2 <- (3 * triad_w2ru$X300)/(triad_w2ru$X201 + 3 * triad_w2ru$X300) #X300 is variable for transitive triad (the fully closed triad)
# we multiply by 3 because there are 3 possible transitive triads
transitivity_w2
  # Returns: [1] 1

```

We find that transitivity of wave 1 is 0.1578947 (from igraph. From the SNA package, gtrans is similar, at 0.1515152). We find that the transitivity of wave 2 is 0.2290909 (from igraph. From the SNA package, gtrans is slightly larger, at 0.2741935). Additionally, when looking at transitive triads, we find transitivity to be 0 in wave 1 and 1 in wave 2. 



**NOTE TO COME BACK TO**: (use this to describe network)
NEED TO INCLUDE TRIADS - TRANSITIVITY 
OUTDEGREE AND RECIPROCITY ARE ALWAYS IN THERE, ALSO NEED OUTDEGREE ACTIVITY OR IN DEGREE POPULARITY. ALSO NEED SOMETHING FOR TRANSITIVITY - GWESP VARIABLE AND EFFECTS TO INCLUDE - MAKE SURE TO INCLUDE ONE OF THESE TOO.



**Notes about network**: 
Network is directional: we can see that with a reciprocity output, we know that the collaborations in this network are directional. 

Reflection: While there is a directional assumption of this social network, in reality the directionality does not matter in the framing of publication output used for merit. The professor that initiated the collaboration, for all intensive purposes, is not directly informative for answering these research questions. Future research that could further investigate the directionality of these collaborations, such as if women or men are more likely to initiate collaborations, would be a way to further develop this research. 



----



## Supplementary Data Manipulation for Cross Gender Collaborations

Next, I would like to create a column added to the Radboud University dataframe (df_ego) that will track if each professor has participated in a cross-gender collaboration in wave 1 and in wave 2. To do so, I first will count the total collaborations in the Radboud professors social network. 

Looking at mydata, I want to investigate the effect of female (male=0, female=1) over collaborations by RU professors. I also want to compare this effect to controls/statistics (egoX, sameX, etc.). To do this, I first will look at if professors have cross gender collaborations, and to count the total number of cross gender collaborations that take place in each wave. 

Next, I will create a function to count the number of collaborations in wave 1 and wave 2 that happened with at least one male and one female. This will then support answering RESEARCH QUESTION 1, as it directly will answer the proportion of collaborations that happen with same gender professors at Radboud. When expanding this function to all universities, I will also be able to tell how it varies by university. 

### Count total collaborations
```{r}
# Total number of collaboration ties in each wave
total_ties_w1 <- sum(test$nets[1,,]) # 31 total ties in Wave 1, same as edges
total_ties_w2 <- sum(test$nets[2,,]) # 85 total ties in Wave 2, same as edges 


# Count total unique collaborations (both outgoing and incoming)
df_ego$collab_total_w1 <- rowSums(test$nets[1,,]) # + colSums(test$nets[1,,])
df_ego$collab_total_w2 <- rowSums(test$nets[2,,]) # + colSums(test$nets[2,,])

sum(df_ego$collab_total_w1) # 31, confirmation that collaborations = edges 
sum(df_ego$collab_total_w2) # 85 
```
This confirms the count of total collaborations as 31 for wave 1, and 85 for wave 2, the same total as indicated with "edges" in the descriptive statistics. I retrieve the count in a different way though, as I build on this function when I next count the number of cross-gender collaborations out of the total collaborations. 


### Count cross gender ties in W1 and W2 
To answer RESEARCH QUESTION 2.1, "What proportion of collaborations happen across gender?", I create a function that will count the number of cross gender collaborations. 


### Count the number of collaborations that happened between different genders 
```{r}
# RQ1.1: Loop over network of who connects with whom, return count of different gender collaborations** 

# Function to count cross-gender ties 
count_xgen <- function(test, gender) {
  edges <- which(test != 0, arr.ind = TRUE)
  sum (
    (gender[edges[,1]] == "female" & gender[edges[,2]] == "male") | 
      (gender[edges[,1]] == "male" & gender[edges[,2]] == "female") 
    )
}

# Wave 1
valid_nodes_w1 <- which(!is.na(df_ego$gender))
adj_w1_clean <- test$nets[1, valid_nodes_w1, valid_nodes_w1]
discipline_w1_clean <- df_ego$gender[valid_nodes_w1]

xgen_w1 <- count_xgen(adj_w1_clean, discipline_w1_clean)


# Wave 2 -- swap w W1
valid_nodes_w2 <- which(!is.na(df_ego$gender))
adj_w2_clean <- test$nets[2, valid_nodes_w2, valid_nodes_w2]
discipline_w2_clean <- df_ego$gender[valid_nodes_w2]

xgen_w2 <- count_xgen(adj_w2_clean, discipline_w2_clean)


#make summary table
cross_gender_collabs_table <- data.frame(wave = c(1, 2), 
                              cross_gender_ties = c(xgen_w1, xgen_w2))


print(cross_gender_collabs_table)
```
wave    cross_gender_ties
1     	10			
2	      33	

This table demonstrates the findings that 10 of the 31 collaborations in wave 1 of Radboud University political science and sociology professors happened in a collaboration with at least one male and one female. It also demonstrates that 33 out of 85 of the total collaborations in wave 2 happened with cross-gender collaboration. This indicates that not only did the amount of collaborations and the amount of cross-gender collaborations increase from wave 1 to wave 2, but that the proportion of cross-gender collaborations out of all of the collaborations also increased. 


### Count the number of collaborations that happened between the same genders 
Next, I use the same function structure to count the same gender ties. This will serve to answer the second part of RESEARCH QUESTION 2,  and will function as a double-check to confirm that the sum of the cross-gender and same-gender collaborations is equal to the total collaborations already accounted for with the number of edges/count of collabortions already found.
```{r}
# RQ1.2 REVERSE OF 1.1: Loop over network of who connects with whom, return if same gender or different gender** 

# Function to count same-gender ties 
count_same_gen <- function(test, gender) {
  edges <- which(test != 0, arr.ind = TRUE)
  sum (
    (gender[edges[,1]] == "male" & gender[edges[,2]] == "male") | 
      (gender[edges[,1]] == "female" & gender[edges[,2]] == "female") 
    )
}


# Wave 1
validnodesw1 <- which(!is.na(df_ego$gender))
adjw1clean <- test$nets[1, validnodesw1, validnodesw1]
disciplinew1clean <- df_ego$gender[validnodesw1]

same_gen_w1 <- count_same_gen(adjw1clean, disciplinew1clean)

# Wave 2 -- swap w W1
validnodesw2 <- which(!is.na(df_ego$gender))
adjw2clean <- test$nets[2, validnodesw2, validnodesw2]
disciplinew2clean <- df_ego$gender[validnodesw2]

same_gen_w2 <- count_same_gen(adjw2clean, disciplinew2clean)

#make summary table
same_gender_collabs_table <- data.frame(wave = c(1, 2), 
                              same_gender_ties = c(same_gen_w1, same_gen_w2))

print(same_gender_collabs_table)

#same gender collaborations: 21 in wave 1, 52 in wave 2. 

```
wave    same_gender_ties
1   	  21			
2	      52	


Confirmation: total number ties/edges/collaborations W1 = 31, 10 = xgen, 21 = same_gen
              total number ties/edges/collaborations W2 = 85, 33 = xgen, 52 = same_gen


This table demonstrates the findings that 21 of the 31 collaborations in Wave 1 happened with professors with the same gender at Radboud University. It also demonstrates that 52 out of 85 of the collaborations in wave 2 happened professors having the same gender. This indicates that same-gender collaborations remain the majority of collaborations that take place, however conversely to cross-gender collaborations, the proportion of same-gender collaborations decreases between wave 1 and wave 2. 



## Counting the cross gender collaborations per professor
Create column to count if each professor has participated in a collaboration with at least one male and one female.

#### Create function to count if ego has collaborated with another gender professor, and apply to waves 1 and 2 
```{r}
# Make function to check if an ego has cross-gender collaborations
has_cross_gender_collab <- function(wave_net, ego_idx, ego_gender, all_genders) {
  # Get all collaborations for this ego (both outgoing and incoming)
  outgoing <- which(wave_net[ego_idx, ] != 0)  # who ego collaborates with, identify ego gender 
  incoming <- which(wave_net[, ego_idx] != 0)  # who collaborates with ego, identify collaborator/alter gender characteristic
  all_collabs <- unique(c(outgoing, incoming))

  # If no collaborations, return 0 - We are focused on the patterns with collaborations.
  if (length(all_collabs) == 0) {
    return(0)
  }
  
  # Check if any collaborator has different gender: Go through each collaboration, then each collaborator that work, and if any of the collaborators have a different gender than the first ego, return value to represent this!
  collab_genders <- all_genders[all_collabs]
  has_xgen <- any(collab_genders != ego_gender) # & !is.na(collab_genders))
  
  return(as.integer(has_xgen))
}



# Next: 
# Apply function to Wave 1: Count the cross-gender collaborations per ego in Wave 1
df_ego$xgen_w1 <- sapply(1:nrow(df_ego), function(i) {
  if (is.na(df_ego$gender[i])) {
    return(NA)
  }
  has_cross_gender_collab(
    wave_net = test$nets[1,,],
    ego_idx = i,
    ego_gender = df_ego$gender[i],
    all_genders = df_ego$gender
  )
})



# Apply function to Wave 2: Count the cross-gender collaborations per ego in Wave 2
df_ego$xgen_w2 <- sapply(1:nrow(df_ego), function(i) {
  if (is.na(df_ego$gender[i])) {
    return(NA)
  }
  has_cross_gender_collab(
    wave_net = test$nets[2,,],
    ego_idx = i,
    ego_gender = df_ego$gender[i],
    all_genders = df_ego$gender
  )
})
```



**Next** 
Results: Summary of the number of male and female professors who did and didn't participate in cross-gender collaborations


### Total proportion of professors participating in cross-gender collaborations
```{r}
# See how many professors had cross-gender collabs in each wave
summary_table <- data.frame(
  wave = c("Wave 1", "Wave 2"),
  profs_with_xgen = c(sum(df_ego$xgen_w1, na.rm = TRUE), 
                      sum(df_ego$xgen_w2, na.rm = TRUE)),
  profs_without_xgen = c(sum(df_ego$xgen_w1 == 0, na.rm = TRUE),
                         sum(df_ego$xgen_w2 == 0, na.rm = TRUE))
)
print(summary_table)
```
Radboud Totals: 
wave    profs_with_xgen     profs_without_xgen
1	      12                	98		
2	      31	                79	

Proportions: 12/110 professors participated in cross-gender collaborations in wave 1, while 31/110 professors participated in cross-gender collaborations in wave 2. Looking at the number of professors participating in cross-gender collaborations, we can see that the proportion of professors participating in cross-gender collaborations increases between wave 1 and wave 2. 

Disclaimer: As a reminder, the number of professors participating in cross-gender collaborations is different than the number of cross-gender collaborations altogether. It is understandable why the number of professors and ties will vary: the number of professors participating in a collaboration can vary, and so while the functions used may count "1" cross-gender collaboration, this cross-gender collaboration could include more than two authors, such that the number of professors participating in the cross-gender collaboration is higher than the count of cross gender collaborations. Alternatively, if the same male and female professors collaborate on multiple works, then the count of cross-gender collaborations will exceed the number of egos involved in the cross gender collaborations. 


### Count/Compare number of ties and number of professors involved in ties 
```{r}
# Wave 1 analysis
# 1. Count professors with at least one cross-gender collab
profs_with_xgen_w1 <- sum(df_ego$xgen_w1 == 1, na.rm = TRUE) 
profs_with_xgen_w1 # Counts 12 professors 

# 2. Count total cross-gender ties in network
total_xgen_ties_w1 <- xgen_w1  # from your count_xgen function: 
total_xgen_ties_w1 #Counts 10 cross-gender ties 



# Same for Wave 2
profs_with_xgen_w2 <- sum(df_ego$xgen_w2 == 1, na.rm = TRUE)
profs_with_xgen_w2 # Counts 31 professors 

total_xgen_ties_w2 <- xgen_w2
total_xgen_ties_w2 # Counts 33 cross-gender ties 

```


### Wave 1 Proportion of male and female professors participating in cross-gender collaborations
```{r}
# View summary
table(df_ego$xgen_w1, df_ego$female, useNA = "ifany")
 # count number of male and female professors who did and did not participate in x gender collaborations
 # finds: Female: 49 = no xgen, 7 = xgen
        # Male:   49 = no xgen, 5 = xgen
```
I find that 7 female professors participate in cross-gender collaborations and 49 female professors do not (including both the professors that collaborated with same gender and the professors that did not collaborate with anyone else) among political science and sociology professors at Radboud University during wave 1. Similarly, 5 male professors participate in cross-gender collaborations and 49 male professors do not, conveying similar proportion of participation in cross-gender collaboration by gender. 

### Wave 2 Proportion of male and female professors participating in cross-gender collaborations
```{r}
table(df_ego$xgen_w2, df_ego$female, useNA = "ifany")
 # count number of male and female professors who did and did not participate in x gender collaborations
 # finds: Female: 37 = no xgen, 19 = xgen
        # Male:   42 = no xgen, 12 = xgen
```
I find that 19 female professors participate in cross-gender collaborations and 37 female professors do not among political science and sociology professors at Radboud University during wave 2, while 12 male professors participate in cross-gender collaborations and 42 male professors do not. This demonstrates that a larger proportion of women participate in cross-gender collaborations than men. 

These are preliminary findings though, and could be effected by discipline. As a result, we must account/control for discipline to better understand if differences in collaborations, and particularly cross-gender collaborations, vary per discipline. 

### Wave 1 Gender/Discipline/Cross-gender collaborations table 
### TIDY TABLE SYNTAX
```{r}
xgen_by_gender_discipline <- df_ego %>%
  filter(!is.na(female) & !is.na(xgen_w1) & !is.na(discipline.24)) %>%
  group_by(discipline.24, female) %>%
  summarise(
    total_professors = n(),
    with_xgen_collab = sum(xgen_w1 == 1, na.rm = TRUE),
    without_xgen_collab = sum(xgen_w1 == 0, na.rm = TRUE),
    proportion_with_xgen = round(sum(xgen_w1 == 1) / n() * 100, 2),
    .groups = "drop"
  ) %>%
  arrange(discipline.24, female)

print(xgen_by_gender_discipline)
```

The variables represented in the table are as follows: 
-    Disciplines: Political science is referred to as "politicologie" while sociology is referred to as "sociologie" in this dataset. 
-    Gender binary: As a reminder, females are denoted with a "1" while men are denoted with a "0". 

In comparing the number of professors of political science and sociology at Radboud University that participated in cross-gender collaborations in wave 1, it becomes evident that while the same number of male and female professors participate in cross-gender collaborations from the political science discipline, more female than male professors in sociology participate in cross-gender collaborations. The statistical significance of these findings is difficult to establish with such a small sample size, which is why these methods will next be applied to all universities. 


### Wave 1 Gender/Discipline/Cross-gender collaborations table - Chi-squared check.
```{r}
# Test if gender and discipline affect cross-gender collaboration rates
# Create contingency table
contingency_table <- df_ego %>%
  filter(!is.na(female) & !is.na(xgen_w1) & !is.na(discipline.24)) %>%
  count(discipline.24, female, xgen_w1) %>%
  pivot_wider(names_from = xgen_w1, values_from = n, values_fill = 0)

# Chi-square test for independence
chisq.test(table(df_ego$female, df_ego$xgen_w1))
chisq.test(table(df_ego$discipline.24, df_ego$xgen_w1))
```
Pearson's Chi-squared test with Yates' continuity correction for gender effect on cross-gender collaborations results in a preliminary finding of X-squared = 0.057193, df = 1, and a p-value of 0.811. This finding fails to reject the null hypothesis that female ego-level characteristic correlates with cross-gender collaborations. 

Pearson's Chi-squared test with Yates' continuity correction for discipline effect on cross-gender collaborations results in a preliminary finding of X-squared = 4.4613, df = 1, and a p-value of 0.03467. This finding provides evidence to reject the null hypothesis that discipline does not have an effect on cross-gender collaborations.  


### Wave 2 Gender/Discipline/Cross-gender collaborations table 
```{r}
xgen_by_gender_discipline2 <- df_ego %>%
  filter(!is.na(female) & !is.na(xgen_w2) & !is.na(discipline.24)) %>%
  group_by(discipline.24, female) %>%
  summarise(
    total_professors = n(),
    with_xgen_collab = sum(xgen_w2 == 1, na.rm = TRUE),
    without_xgen_collab = sum(xgen_w2 == 0, na.rm = TRUE),
    proportion_with_xgen = round(sum(xgen_w2 == 1) / n() * 100, 2),
    .groups = "drop"
  ) %>%
  arrange(discipline.24, female)

print(xgen_by_gender_discipline2)
```
Comparing the number of professors that participated in cross-gender collaborations in wave 2, we see that while a similar number of male and female professors participate in cross-gender collaborations from the political science discipline, more female than male professors in sociology participate in cross-gender collaborations. Further, we see overall that sociology professors participate in cross-gender collaborations at a much higher amount and proportion compared to political science professors. The statistical significance of these findings is difficult to establish with such a small sample size, which is why these methods will next be applied to all universities. 

### Wave 2 Gender/Discipline/Cross-gender collaborations table - Chi-squared check.
```{r}
contingency_table <- df_ego %>%
  filter(!is.na(female) & !is.na(xgen_w2) & !is.na(discipline.24)) %>%
  count(discipline.24, female, xgen_w2) %>%
  pivot_wider(names_from = xgen_w2, values_from = n, values_fill = 0)

# Chi-square test for independence
chisq.test(table(df_ego$female, df_ego$xgen_w2))
chisq.test(table(df_ego$discipline.24, df_ego$xgen_w2))
```
Pearson's Chi-squared test with Yates' continuity correction for gender effect on cross-gender collaborations results in a preliminary finding of X-squared = 1.3279, df = 1, and a p-value of 0.2492. This finding fails to reject the null hypothesis that female ego-level characteristic correlates with cross-gender collaborations. 

Pearson's Chi-squared test with Yates' continuity correction for discipline effect on cross-gender collaborations results in a preliminary finding of X-squared = 8.9736, df = 1, and a p-value of 0.002739. This finding provides evidence to reject the null hypothesis that discipline does not have an effect on cross-gender collaborations. 


### Create column to count the number of cross gender collaborations per professor
```{r}
# Count how many cross-gender collaborations each professor has
df_ego$xgen_count_w1 <- sapply(1:nrow(df_ego), function(i) {
  if (is.na(df_ego$gender[i])) return(NA)
  
  # Get ego's outgoing and incoming ties
  outgoing <- which(test$nets[1,i,] != 0)
  incoming <- which(test$nets[1,,i] != 0)
  all_collabs <- unique(c(outgoing, incoming))
  
  # Count how many have different gender
  if (length(all_collabs) == 0) return(0)
  
  sum(df_ego$gender[all_collabs] != df_ego$gender[i] & 
      !is.na(df_ego$gender[all_collabs]))
})

df_ego$xgen_count_w2 <- sapply(1:nrow(df_ego), function(i) {
  if (is.na(df_ego$gender[i])) return(NA)
  
  outgoing <- which(test$nets[2,i,] != 0)
  incoming <- which(test$nets[2,,i] != 0)
  all_collabs <- unique(c(outgoing, incoming))
  
  if (length(all_collabs) == 0) return(0)
  
  sum(df_ego$gender[all_collabs] != df_ego$gender[i] & 
      !is.na(df_ego$gender[all_collabs]))
})


# Distribution of cross-gender collaborations
table(df_ego$xgen_count_w1, useNA = "ifany")
# Distribution in Wave 1: # of professors (bottom) with # of xgen collabs (top)
#   0    1    2    3 <NA> 
#  98    9    2    1    1 


table(df_ego$xgen_count_w2, useNA = "ifany")
# Distribution in Wave 1: # of professors (bottom) with # of xgen collabs (top)
#   0    1    2    3    5    7 <NA> 
#  79   16    9    3    2    1    1 

# Summary statistics
summary(df_ego$xgen_count_w1)
summary(df_ego$xgen_count_w2)


# MAKE COLUMN WITH THE NEW X GENDER COLLABORATIONS FORMED SINCE WAVE 1
df_ego$xgen_count_new <- (df_ego$xgen_count_w2) - (df_ego$xgen_count_w1)

```
Lastly, I create a column to count the number of cross gender collaborations per professor, to better understand the distribution of cross-gender collaborations by professor. 

Unfortunately my analysis does not cover this, as it is not relevant to my research question, but I found it an interesting exercise and a potential point for departure as a recommendation for further research. 



----



## RSiena Analysis - Radboud Profs

### Looking at Degree and Reciprocity from Ministeps -- NOTE TO SELF: DELETE OR COME BACK TO
```{r}
# I HONESTLY HAVE NO IDEA - FROM CODEREVIEW3

packages = c("RSiena", "devtools", "igraph")
fpackage.check(packages)
# devtools::install_github('JochemTolsma/RsienaTwoStep', build_vignettes=TRUE)
packages = c("RsienaTwoStep")
fpackage.check(packages)


ego <- ts_select(net = test$nets[1,,]) # do I need to pick a wave? 
options <- ts_alternatives_ministep(net = test$nets[1,,], ego = ego)


# Calculate # degrees ego has 
ts_degree(net = options[[1]], ego = ego)
sapply(options, ts_degree, ego = ego)


# Can do the same for reciprocity
sapply(options, ts_recip, ego = ego)


simnet2 <- ts_sim(
        net1=test$nets[1,,], #this is our start netwwork
        statistics=list(ts_degree, ts_recip), #we only include to statistics
        startvalues = c(2,-1,1.5)) # the start values for our rate parameter (automatically included), and our two statistics

simnet2

```


### Reminder of dependent and independent variables
```{r}
# DEPENDENT VARIABLE
# net = dependent variable (the ties are the dependent variable)

# INDEPENDENT VARIABLES
# female <- already coCovar
# polsci <- already coCovar - control

```


### For reference: RESEARCH QUESTIONS: 

### Rsiena Analysis: RQ 1
**Research Question 1** (Descriptive): What proportion of collaborations happen with professors that have different genders? 
-    a.	What proportion of collaborations happen with professors that have the same gender? 
-    b.	How does this vary per department (political science vs. sociology)? 

Hypotheses: 
I hypothesize that female professors are more likely to participate in cross-gender collaborations. 

I hypothesize that female professors in political science are more likely to participate in cross-gender collaborations than their male counter parts, as a field with continued gender imbalances that may leave women with increased pressure to publish works and partner with established males in order to gain credibility and promotions. 

I also hypothesize that cross-gender collaborations will be more frequent in departments with more balanced gender representation (close to 50% female population of professors). 

Further, building on my assumptions in my first two hypotheses, I hypothesize that female professors in sociology are even more likely to participate in cross-gender collaborations, as the effect of women being more likely to participate in cross-gender collaborations is amplified with the more even proportion of women in sociology, and potentially a more progressive department culture toward cross-gender collaborations as a result. 


To answer my first research question, I will develop several tables summarizing the data analysis of cross-gender collaborations by gender, discipline, and wave. I will look at the total number of collaborations across both waves, and the proportion of cross-gender and same-gender collaborations out of these. I will also look at the total amount of male and female professors participating in the cross-gender collaborations, and the amount of male and female professors by discipline, to better understand and control for differences in departments. In comparing all of these, we will be able to see the proportions of cross-gender collaborations out of total collaborations over time, the proportion of male and female participation, and the variation in proportion of male and female participation by department, providing us a comprehensive understanding of gender and cross-gender collaboration effects. 


### Rsiena Analysis: RQ 2
**Research Question 2** (Explanatory, Hypothesis testing): How does gender effect potential for collaborations? 
-    Is one gender more likely to collaborate than the other? 


I hypothesize that women are more likely to collaborate than men, such that 'female' as an ego-level characteristic increases the potential for collaborations. 

I hypothesize that furthermore, 'female' as an ego-level characteristic increases the potential for cross-gender collaborations.


How to answer: Look at egoX effect, including the interaction with "female" and the control for department with "polsci". 
To answer my second research question, I will use an rsiena model looking at the egoX effect, and the interaction with "female", controlling for academic discipline. The rsiena model will simulate collaborations and compare the expected results of the impact of 'female' with the actual data in order to gauge the effect 'female' has on the potential for collaborations. 


## Rsiena results
For Radboud University in particular.
INPUT FROM FILE: finalpaper_ru

We will be looking at female (independent variable) effect on collaborations, including controls for discipline. I created several rsiena models in order to compare and see how much of an effect the different statistics, variables, controls have on the overall estimated model.


### ansM1 - Looking at (net, female): isolateNet, inPop.c, and egoX of "female"
``` {r}
 #check this later tho
mydata = sienaDataCreate(net, female) 
myeff = getEffects(mydata)
myeff = includeEffects(myeff, isolateNet, inPop.c)
myeff = includeEffects(myeff, egoX, interaction1 = "female") # Independent variable under investigation

# ONLY LOOKING AT FEMALE EFFECT FIRST - look at this in ansM3
# myeff = includeEffects(myeff, egoX, interaction1 = "polsci") # Control for sociology vs political science departments

# myeff = includeEffects(myeff, egoX, altX, diffX, interaction1 = "female") -- removing altX and diffX because they didn't help initial model at all! 


myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM1 = siena07(
    myAlgorithm, 
    data = mydata, 
    effects = myeff,
    returnDeps = TRUE
)

ansM1

```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                2.6776  ( 0.4955   )             

Other parameters: 
  1. eval outdegree (density)          -1.7542  ( 0.8515   )    0.2033   
  2. eval reciprocity                   1.5298  ( 0.5151   )   -0.2035   
  3. eval indegree-popularity (centrd)  0.4095  ( 0.0873   )    0.3796   
  4. eval network-isolate               6.5281  ( 2.1119   )   -0.2386   
  5. eval female ego                    2.0429  ( 1.4349   )   -0.0111   

Overall maximum convergence ratio:    0.4158 


### ansM2 - Looking at (net, female): isolateNet, inPop.c, and egoX and sameX of "female"
```{r}
mydata2 = sienaDataCreate(net, female) 
myeff2 = getEffects(mydata2)
myeff2 = includeEffects(myeff, isolateNet, inPop.c)
myeff2 = includeEffects(myeff, egoX, sameX, interaction1 = "female") # better to include sameX too? 

myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM2 = siena07(
    myAlgorithm, 
    data = mydata2, 
    effects = myeff2,
    returnDeps = TRUE
)
ansM2

#prevAns function - rsiena manual, add code to algorithm. siena 07 model. 

```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                2.7969  ( 0.5123   )             

Other parameters: 
  1. eval outdegree (density)          -2.0130  ( 1.0826   )    0.0848   
  2. eval reciprocity                   1.4854  ( 0.4972   )   -0.0243   
  3. eval indegree-popularity (centrd)  0.4111  ( 0.1205   )    0.2808   
  4. eval network-isolate               6.6122  ( 2.6827   )    0.0217   
  5. eval female ego                    2.0964  ( 1.7283   )   -0.0700   
  6. eval same female                   0.4344  ( 0.2658   )   -0.0099   

Overall maximum convergence ratio:    0.3302 


Total of 2769 iteration steps.


**Note:** Evidently, ansM2 has better t-ratios and convergence than ansM1.  


### ansM3 - Looking at (net, female, polsci): isolateNet, inPop.c, and egoX and sameX of "female", Compare with polsci
```{r}
# Exclude NAs from polsci to then be able analyze. need to exclude, since 0=soc and 1=polsci as discipline.
polsci = coCovar(na.omit(df_ego$polsci))
table(df_ego$polsci) # make sure is right -> SUM IS 111, check :) 
polsci = coCovar(df_ego$polsci) #reset again just in case

# make rsiena model
mydata3 = sienaDataCreate(net, female, polsci) 

myeff3 = getEffects(mydata3)
myeff3 = includeEffects(myeff3, isolateNet, inPop.c)

myeff3 = includeEffects(myeff3, egoX, sameX, interaction1 = "female")
myeff3 = includeEffects(myeff3, egoX, interaction1 = "polsci")


myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM3 = siena07(
    myAlgorithm, 
    data = mydata3, 
    effects = myeff3,
    returnDeps = TRUE
)

ansM3
```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                2.8348  ( 0.5193   )             

Other parameters: 
  1. eval outdegree (density)          -2.2587  ( 0.5963   )    0.1835   
  2. eval reciprocity                   1.7074  ( 0.5144   )   -0.0569   
  3. eval indegree-popularity (centrd)  0.3988  ( 0.0732   )    0.3170   
  4. eval network-isolate               6.1445  ( 1.7461   )   -0.1654   
  5. eval female ego                    1.8925  ( 1.1141   )   -0.0548   
  6. eval polsci ego                   -1.5269  ( 0.7038   )    0.0297   

Overall maximum convergence ratio:    0.3233 


Total of 2669 iteration steps.




### ansM4 - Looking at (net, female, xgen_w1): isolateNet, inPop.c, and egoX and sameX of "female", Compare with xgen_w1
```{r}
mydata4 = sienaDataCreate(net, female, xgen_w1) 
myeff4 = getEffects(mydata4)
myeff4 = includeEffects(myeff4, isolateNet, inPop.c)
```


```{r, eval=FALSE}
myeff4 = includeEffects(myeff4, egoX, sameX, interaction1 = "female")
myeff4 = includeEffects(myeff4, egoX, interaction1 = "xgen_w1")

myeff4 = includeInteraction(myeff4, egoX, egoX, interaction1 = c("female", "xgen_w1"))

myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM4 = siena07(
    myAlgorithm, 
    data = mydata4, 
    effects = myeff4,
    returnDeps = TRUE
)

ansM4

fsave(ansM4)
```


```{r}
ansM4_load <- fload('data/processed/ansM4_20251031.rda')

ansM4_load
```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                2.7817  ( 0.5506   )             

Other parameters: 
  1. eval outdegree (density)          -1.8989  ( 0.7928   )    0.1299   
  2. eval reciprocity                   1.6968  ( 0.5112   )   -0.0697   
  3. eval indegree-popularity (centrd)  0.3995  ( 0.0650   )    0.3252   
  4. eval network-isolate               6.3412  ( 1.8160   )   -0.1035   
  5. eval female ego                    1.6089  ( 1.4444   )   -0.1207   
  6. eval xgen_w1 ego                  -0.0535  ( 0.6632   )   -0.0078   
  7. eval female ego x xgen_w1 ego      1.3680  ( 1.3069   )   -0.0304   

Overall maximum convergence ratio:    0.3382 


### ansM5 - Looking at (net, female, xgen_w2): isolateNet, inPop.c, and egoX and sameX of "female", Compare with xgen_w2
```{r}
mydata5 = sienaDataCreate(net, female, xgen_w2) 
myeff5 = getEffects(mydata5)
myeff5 = includeEffects(myeff5, isolateNet, inPop.c)

myeff5 = includeEffects(myeff5, egoX, sameX, interaction1 = "female")
myeff5 = includeEffects(myeff5, egoX, interaction1 = "xgen_w2")

myeff5 = includeInteraction(myeff5, egoX, egoX, interaction1 = c("female", "xgen_w2"))

myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM5 = siena07(
    myAlgorithm, 
    data = mydata5, 
    effects = myeff5,
    returnDeps = TRUE
)

ansM5

```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                3.2685  ( 0.6659   )             

Other parameters: 
  1. eval outdegree (density)          -3.1810  ( 0.5869   )    0.1448   
  2. eval reciprocity                   1.6180  ( 0.5015   )   -0.0585   
  3. eval indegree-popularity (centrd)  0.3901  ( 0.0692   )    0.2838   
  4. eval network-isolate               5.9564  ( 2.2973   )   -0.0727   
  5. eval female ego                    0.0981  ( 0.8621   )   -0.0965   
  6. eval same female                   0.4685  ( 0.2298   )    0.0760   
  7. eval xgen_w2 ego                   1.9660  ( 0.7161   )    0.0176   
  8. eval female ego x xgen_w2 ego      3.6691  ( 1.6910   )   -0.0964   

Overall maximum convergence ratio:    0.3063 


Total of 2863 iteration steps.

Is the better of the two waves of cross-gender collaboration data. 




### Make new CoVariable - Cross Generation Collaboration
```{r}
# Wave 1
xgen_w1 = coCovar(df_ego$xgen_w1)
 # NAs make it difficult: since not "1", make "0": 

df_ego$xgen_w1[is.na(df_ego$xgen_w1)] <- 0
table(df_ego$xgen_w1) # make sure is right
xgen_w1 = coCovar(df_ego$xgen_w1) #reset again just in case

# and recode Wave 2 
df_ego$xgen_w2[is.na(df_ego$xgen_w2) <- 0]
xgen_w2 = coCovar(df_ego$xgen_w2)

# matrix - variation of the two
xgen_varying = varCovar(cbind(df_ego$xgen_w1, df_ego$xgen_w2))
```


### ansM6 - Looking at (net, female): isolateNet, inPop.c, and egoX and sameX of "female", Compare with polsci and varCovar "xgen_varying" of both xgen timeframes (difference from w1 to w2)
```{r}
mydata6 = sienaDataCreate(net, female) 
myeff6 = getEffects(mydata6)
myeff6 = includeEffects(myeff6, isolateNet, inPop.c)

myeff6 = includeEffects(myeff6, egoX, sameX, interaction1 = "female")
myeff6 = includeEffects(myeff6, egoX, interaction1 = "polsci")
myeff6 = includeEffects(myeff6, egoX, interaction1 = "xgen_varying") # took a really long time? 


myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM6 = siena07(
    myAlgorithm, 
    data = mydata6, 
    effects = myeff6,
    returnDeps = TRUE
)

ansM6
```
Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                2.7328  ( 0.5124   )             

Other parameters: 
  1. eval outdegree (density)          -1.6350  ( 0.8571   )    0.2210   
  2. eval reciprocity                   1.5251  ( 0.5142   )   -0.0646   
  3. eval indegree-popularity (centrd)  0.4038  ( 0.0764   )    0.3387   
  4. eval network-isolate               6.8822  ( 2.1717   )   -0.0812   
  5. eval female ego                    2.2611  ( 1.5534   )   -0.0222   

Overall maximum convergence ratio:    0.3665 


## Final Rsiena Model -

### ansM7 - Looking at (net, female, xgen_w2, polsci): isolateNet, inPop.c, and egoX and sameX of "female", Compare with polsci, xgen_w2, and female interaction with xgen_w2 collaborations (controlling for discipline)
```{r}
mydata7 = sienaDataCreate(net, female, xgen_w2, polsci) 
myeff7 = getEffects(mydata7)
myeff7 = includeEffects(myeff7, isolateNet, inPop.c)

myeff7 = includeEffects(myeff7, egoX, sameX, interaction1 = "female")
myeff7 = includeEffects(myeff7, egoX, interaction1 = "polsci") #do I need to include polsci in mydata7? 
myeff7 = includeEffects(myeff7, egoX, interaction1 = "xgen_w2") # took a really long time? 
myeff7 = includeInteraction(myeff7, egoX, egoX, interaction1 = c("female", "xgen_w2"))


myeff7 = includeInteraction(myeff7, egoX, sameX, interaction1 = c("female", "female"))



myAlgorithm = sienaAlgorithmCreate(
    projname = "finalpaper_ru")

ansM7 = siena07(
    myAlgorithm, 
    data = mydata7, 
    effects = myeff7,
    returnDeps = TRUE
)

ansM7
```

Estimates, standard errors and convergence t-ratios

                                       Estimate   Standard   Convergence 
                                                    Error      t-ratio   

Rate parameters: 
  0       Rate parameter                3.3314  ( 0.6744   )             

Other parameters: 
  1. eval outdegree (density)          -3.1895  ( 0.6194   )    0.0149   
  2. eval reciprocity                   1.6653  ( 0.4639   )    0.0185   
  3. eval indegree-popularity (centrd)  0.3810  ( 0.0715   )    0.2146   
  4. eval network-isolate               5.9787  ( 2.5035   )    0.0494   
  5. eval female ego                    0.2048  ( 0.8337   )   -0.0284   
  6. eval same female                   0.4708  ( 0.2368   )   -0.0264   
  7. eval xgen_w2 ego                   1.7380  ( 0.7486   )   -0.0663   
  8. eval polsci ego                   -0.5145  ( 0.5828   )    0.0242   
  9. eval female ego x xgen_w2 ego      3.6162  ( 1.8200   )   -0.0249   

Overall maximum convergence ratio:    0.2779 


Total of 2877 iteration steps.


### ansM8 - Control for each university - COME BACK TO THIS 
```{r}
#radboud

#radboud = coCovar(df_ego$universiteit.22)



```



## RSiena results of ansM7

**1**
Estimation by stochastic approximation algorithm.
=================================================

Random initialization of random number stream.
Current random number seed is 996516.
Effects object used: myeff7 
Model Type:
 Standard actor-oriented model 
Estimation method: conditional moment estimation.
Conditioning variable is the total number of observed changes ("distance") 
in the network variable.
Distance for simulations is   82 .
Standard errors are estimated with the likelihood ratio method.
Dolby method (regression on scores) is used.
Initial value of gain parameter is  0.2000000.
Reduction factor for gain parameter is  0.5000000.
Number of subphases in Phase 2 is 4.

Initial parameter values are 
  0. Rate parameter                           1.4926
  1. eval:  outdegree (density)                            -1.5585
  2. eval:  reciprocity                                     0.0000
  3. eval:  indegree-popularity (centrd)                    0.0000
  4. eval:  network-isolate                                 0.0000
  5. eval:  female ego                                      0.0000
  6. eval:  same female                                     0.0000
  7. eval:  xgen_w2 ego                                     0.0000
  8. eval:  polsci ego                                      0.0000
  9. eval:  female ego x xgen_w2 ego                        0.0000


Values of target statistics are
  1. Number of ties                                                      85.0000
  2. Number of reciprocated ties                                         14.0000
  3. Sum of squared indegrees (centrd)                                  370.5856
  4. Number of isolates                                                  56.0000
  5. Sum outdegrees x female                                              3.7273
  6. Same values on female                                               52.0000
  7. Sum outdegrees x xgen_w2                                            34.0455
  8. Sum outdegrees x polsci                                            -21.1171
  9. female ego x xgen_w2 ego                                             8.4223
These were calculated from the data.

 9 parameters, 9 statistics

Estimation of derivatives by the LR method (type 1).


**2**
End of stochastic approximation algorithm, phase 3.
---------------------------------------------------

Total of 2877 iterations.
Parameter estimates based on 1877 iterations,
basic rate parameter as well as 
convergence diagnostics, covariance and derivative matrices based on 1000 iterations.

Information for convergence diagnosis.
Averages, standard deviations, and t-ratios for deviations from targets:
  1.   0.1120   7.5273   0.0149 
  2.   0.0860   4.6435   0.0185 
  3.  93.6395 436.3598   0.2146 
  4.   0.2350   4.7567   0.0494 
  5.  -0.1656   5.8302  -0.0284 
  6.  -0.1670   6.3360  -0.0264 
  7.  -0.3535   5.3314  -0.0663 
  8.   0.1125   4.6432   0.0242 
  9.  -0.0649   2.6016  -0.0249 

Good convergence is indicated by the t-ratios being close to zero.

Overall maximum convergence ratio =  0.2779 .



**2**
Estimation Results.
-------------------

Regular end of estimation algorithm.
Total of 2877 iteration steps.


@3
Estimates and standard errors
                             
Rate parameters:
 0. Rate parameter                            3.3314  (   0.6744)

Other parameters:
 1. eval:  outdegree (density)                                    -3.1895  (   0.6194)
 2. eval:  reciprocity                                             1.6653  (   0.4639)
 3. eval:  indegree-popularity (centrd)                            0.3810  (   0.0715)
 4. eval:  network-isolate                                         5.9787  (   2.5035)
 5. eval:  female ego                                              0.2048  (   0.8337)
 6. eval:  same female                                             0.4708  (   0.2368)
 7. eval:  xgen_w2 ego                                             1.7380  (   0.7486)
 8. eval:  polsci ego                                             -0.5145  (   0.5828)
 9. eval:  female ego x xgen_w2 ego                                3.6162  (   1.8200)




This model converges with a maximum convergence ratio of 0.2779, and a rate parameter of 3.3314. There is a negative effect of density ('outdegree') at -3.1895, a positive effect of reciprocity at 1.6653, and a positive effect of in-degree popularity at 0.3810. All of these effects remain significant. 

Further, effects of gender, discipline, and cross-gender collaborations are also included to analyze their impace on collaborations, including EgoX of female, polsci, and xgen_w2, sameX** (preference to working with the same gender) of female, and the interaction between gender and cross-gender collaborations. 

Out of all of these effects introduced to estimate the effect of gender on collaborations, all except for the egoX effect of polsci (discipline qualifying as political science) appear significant. With this, there is evidence that 'female' has a positive effect on collaborations (and particularly collaborations with other females', that 'female' has a positive effect on cross-gender collaborations, and that the interaction of 'female' with cross-gender collaborations has a significant, positive, and relatively large effect (of 3.6162). Additionally, we see that 'female' has a negative effect on 'polsci', providing evidence that 'female' egos are less likely to collaborate in political science disciplines. 



## GOODNESS OF FIT 

With this, we will look at how myeff (which accounts for female as the independent variable) in algorithm actually distributes in indegree and outdegree goodness of fit. 

### Create function
```{r}
# Note: The geodesic distribution is not available from within RSiena, and therefore is copied from the help page of sienaGOF-auxiliary. GeodesicDistribution calculates the distribution of non-directed geodesic distances; 

GeodesicDistribution <- function(i, data, sims, period, groupName, varName, levls = c(1:5, Inf), cumulative = TRUE,
    ...) {
    x <- networkExtraction(i, data, sims, period, groupName, varName)
    require(sna)
    a <- sna::geodist(symmetrize(x))$gdist
    if (cumulative) {
        gdi <- sapply(levls, function(i) {
            sum(a <= i)
        })
    } else {
        gdi <- sapply(levls, function(i) {
            sum(a == i)
        })
    }
    names(gdi) <- as.character(levls)
    gdi
}
```


### GOF for ansM1

#### Indegree:
```{r}
# The following function is taken from the help page for sienaTest -- use "ansM1"

testall <- function(ansM1) {
    for (i in which(ansM1$test)) {
        sct <- score.Test(ansM1, i)
        cat(ansM1$requestedEffects$effectName[i], "\n")
        print(sct)
    }
    invisible(score.Test(ansM1))
}

gofi0 <- sienaGOF(ansM1, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = "net")
# gofi0
plot(gofi0)

# variable name from example = net
# x-axis = indegree 
# y-axis = frequency (plotting the people with 0 in-degrees)

```

#### Outdegree: 
```{r}
# outdegree distribution
gofi1 <- sienaGOF(ansM1, OutdegreeDistribution, verbose = FALSE, join = TRUE, varName = "net")
plot(gofi1)
```


### GOF for ansM7

#### Indegree:
```{r}
gofi_ansM7 <- sienaGOF(ansM7, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = "net")

plot(gofi_ansM7)
```
In this macro-level investigation, we look at the degree of spread over the numerous simulations performed in rseina based on the designated parameters. Then, in the above goodness of fit model, we do an in-degree count. With this, we can see 78 nodes in the observed network at 0 degrees, 93 nodes at 1 degree, and from there the number of nodes levels out from 101-109 nodes across 2-8 degrees. In comparing the red line of actual observations to the boxplot representing the degree of spread and the violin plot representing where the majority of data it, it is evident that this model underestimates the number of isolates and over estimates the number of actors with 3-6 ties, while underestimating the actors with few degrees. In short, we can see that this goodness of fit model underestimates at 0, overestimates between 1-5, and then evens out. 

In testing with the p-value, we test a set of variables against a set of fixed values, combining it into one test that takes into account if there is covariance in the variables. Traditionally that could be done with a t-test, however as this includes a more complicated set of variables, we used the Monte Carlo Mahaloanobis distance test p-value. This renders: 


#### Outdegree: 
```{r}
gofi_ansM7_2 <- sienaGOF(ansM7, OutdegreeDistribution, verbose = FALSE, join = TRUE, varName = "net")

plot(gofi_ansM7_2)
```
We also will look at the goodness of fit of outdegree distribution. As observed in the above goodness of fit model, the outdegree count encounters the opposite over- and underestimation of nodes at their respective degrees as the goodness of fit for the indegree distribution.  With this, we can see 67 nodes in the observed network at 0 degrees (overestimated in the goodness of fit model), 84 nodes at 1 degree (overestimated even more than at 0 degrees), and from there the number of nodes levels out from 101-111 nodes across 2-8 degrees (underestimated in the model).



FACTOR IN GWESP TO MODERATE EFFECT: RETURN TO THIS?


TriadCensus



## RELATIVE INFLUENCE 

Relative Influence Analysis - RU profs 

### Relative influence with ansM1
```{r}
RI <- RSiena:::sienaRI(data = mydata, ans = ansM1)

RSiena:::plot.sienaRI(RI, addPieChart = TRUE)
```
In this micro-level investigation, we look at the proportion of influence of each effect on ego-level tiny-steps in predicting future collaborations. It is important to consider that with a micro-level investigation, when it is relevant there it the potential to have a large effect; however, it might not be relevant to each individual. This looks at whether or not the effects of outdegree, reciprocity, and in-degree popularity are relevant for many professors at Radboud.
 
With this plot, can look at the proportion of each effect on predicting future collaborations. We can see indegree-popularity increase from wave 1 to wave 2? 


### Relative influence with ansM7 -- can't include because of interaction?
```{r}
RI_ansM7 <- RSiena:::sienaRI(data = mydata7, ans = ansM7)

RSiena:::plot.sienaRI(RI_ansM7, addPieChart = TRUE)
```













































----



# For all Universities

## Establish new test: 'test_all' for all universities (using fcolnet) and df_ego_all (bind data rows)
```{r}
# Load data for all universities
scholars$demographics[[12]]

test_all = fcolnet(scholars, 
                university = c('RU', 'UU', 'UvG', 'UvA', 'VU', 'Leiden', 'EUR', 'UvT', 'NA'), # this is where I can expand to all universities to then run
                discipline = c("Sociologie", "Politicologie"),
                type = c("first")) 

# test2 = fcolnet()

df_ego_all = bind_rows(test_all$data)
```


### Wrangle Data Waves, make 'nets' (nets_all) and 'net' (net_all) function for all universities
```{r}
wave1_all = test_all$nets[1,,]
wave2_all = test_all$nets[2,,]
wave3_all = test_all$nets[3,,]

nets_all = array(
    data = c(wave1_all, wave2_all), # don't include wave 3 in final analysis 
    dim = c(dim(wave2_all), 2)
)

net_all = sienaDependent(nets_all)
```


## Isolate Gender variable (binary)
```{r}
# Recoding for gender
df_ego_all = df_ego_all |>
    mutate(
        female_all = case_when(
            gender == "female" ~ 1,
            gender == "male" ~ 0,
            .default = NA 
        )
    )

female_all = coCovar(df_ego_all$female_all) #CREATE GENDER CO VARIABLE

female_all <- na.omit(df_ego_all$female_all) #remove NAs
table(df_ego_all$female_all) #check they are gone

female_all = coCovar(df_ego_all$female_all) # Now make coCovar again, with na.omit-ed data 

```


## Isolate disicipline variable 
```{r}
# Recoding for discipline
df_ego_all = df_ego_all |>
    mutate(
        polsci_all = case_when(
            discipline.22 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.22 == "Sociologie" ~ 0,
            discipline.24 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.24 == "Sociologie" ~ 0,
            discipline.25 == "Politicologie" ~ 1, #assume discipline remains the same?
            discipline.25 == "Sociologie" ~ 0,
            .default = NA
        )
    )

table(df_ego_all$polsci_all) #check that there are no NAs

polsci_all = coCovar(df_ego_all$polsci_all) #CREATE DISCIPLINE CO VAR
```



----

# Preliminary Descriptives

## Distribution of Gender for All Universities (Female = 1)
```{r}
summary(df_ego_all$female_all)
```
The distribution of gender appears relatively balanced, with a mean of 0.5006, indicating potentially slightly more women as professors, though remaining very close to .50, it is reasonable to assume that gender is equally distributed among professors across the Netherlands.  


## Distribution of Discipline for All Universities in the Netherlands (Political Science = 1)
```{r}
summary(df_ego_all$polsci_all)
```
The distribution of discipline appears to slightly favor sociology, with a mean of 0.4232, indicating more sociology professors than political science professors. It is important to pay attention to this, even though the mean still remains somewhat close to .50. 


## Distribution of Gender by Discipline for All Universities (from 2024)
```{r}
table(df_ego_all$female_all, df_ego_all$discipline.24, useNA = "ifany")
```
Noticeably, there are fewer women who are political science professors, with 19 more male professors than female professors, and there are more women who are sociology professors, with 12 more women professors than male professors. This is across universities in the Netherlands though, and with eight universities accounted for, the gender distribution could vary per university. I represent the difference in gender count by discipline with the table above, and I then visualize this in the bar graph below. I use the disciplines counted in 2024 as the latest count from the waves I studied. 


## Plot Distribution of Gender by Discipline
```{r}
library(ggplot2)

df_ego_all %>%
  filter(!is.na(gender) & !is.na(discipline.24)) %>%
  ggplot(aes(x = discipline.24, fill = gender)) +
  geom_bar(position = "dodge") +
  labs(title = "Gender Distribution by Discipline",
       x = "Discipline", 
       y = "Count") +
  theme_minimal()
```






----



# Network Visualizations - All Professors
## Visualizing Waves 1 and 2 for all universities

### Make adjacency matrix for first wave of all_professors data
```{r}
# make adjacency matrix with first wave of data
test_wave1_all <- igraph::graph_from_adjacency_matrix(
  test_all$nets[1,,], #for this example I take the first wave of data. (thus I select the array of networks and take the first matrix)
  mode = c("directed"), # directed from the first author
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NULL
)

test_wave1_all
```


### All Professors Wave 1 - First plot of data (colored: women represented with red and men represented with blue)
```{r}
# changing V: Can make size proportional to betweenness score: V(test_wave1ru)$size = betweenness(test_wave1ru, normalized = T, directed = TRUE) * 100 + 20  #after some trial and error

#plot to see if it worked 
plot(test_wave1_all,
  vertex.color = ifelse(df_ego_all$female_all == 1, "red", "blue"),
  vertex.label = NA,
  edge.width = 0.2,
  vertex.size = sqrt(igraph::degree(test_wave1_all))*3 + 5,
  edge.arrow.size =0.2)

dim(test_wave1_all) #check it works 
sum(is.na(test_wave1_all)) #check it is complete -- if 0 missing values


# how do I plot only the collaborations? 
# test_wave1ru_collabs <- 
```


### Make adjacency matrix for second wave of all_professors data
```{r}
test_wave2_all <- igraph::graph_from_adjacency_matrix(
  test_all$nets[2,,], #for this example I take the first wave of data. (thus I select the array of networks and take the first matrix)
  mode = c("directed"),
  weighted = NULL,
  diag = FALSE,
  add.colnames = NULL,
  add.rownames = NULL
)
```


### All Professors Wave 2 - First plot of data (colored: women represented with red and men represented with blue)
```{r}
# V(test_wave2_all)$size = betweenness(test_wave2ru, normalized = T, directed = TRUE) * 100 + 8  #after some trial and error

#plot to see if it worked 
plot(test_wave2_all,
  vertex.color = ifelse(df_ego_all$female_all == 1, "red", "blue"),
  vertex.label = NA,
  edge.width = 0.2,
  vertex.size = sqrt(igraph::degree(test_wave2_all))*3 + 5,
  edge.arrow.size =0.2)
```





----



# Descriptive Statistics - All Professors 
## NOW - LOOK AT DESCRIPTIVE STATISTICS FOR ALL PROFESSORS 

### General 
```{r}
summary(df_ego_all$female_all)
```
We can see a fairly even distribution of men to women. 


### Size - QUESTION, WHY IS VCOUNT LARGE?
```{r}
#SIZE
# number of nodes for ALL university professors - both sociology and political science 
vcount(test_wave1_all) #returns 794
vcount(test_wave2_all) #returns 794

#SIZE - for reference
# number of nodes for all professors
#vcount(test_w1) #returns 674
#vcount(test_w2) #returns 674
```


### Edges
```{r}
#EDGES
# number of edges for RU professors
ecount(test_wave1_all) #returns 292
ecount(test_wave2_all) #returns 539
```


### Degree
```{r}
#DEGREE
# looking at clustering and spread
igraph::degree(test_wave1_all)
igraph::degree(test_wave2_all)


hist(table(degree(test_wave1_all)), xlab='indegree', main= 'Histogram of indegree') 
# every number is the degree level of each actor -- and see it is heavily skewed to the left
# Wave 1: see frequency of 10 for indegree 0:100, frequency of 0 for indegree 100:500, frequency 1 for indegree 500:650

hist(table(degree(test_wave2_all)), xlab='indegree', main= 'Histogram of indegree') # every number is the degree level of each actor -- and see it is heavily left skewed too  
# Wave 2: see frequency of 10 for indegree 0:100, frequency of 2 for indegree 100:200, 0 for 200:300, 1 for 300:400
```


### Degree Centrality W1 - Wave 1 (distribution of degrees plot)
```{r}
#degree centrality w1 
degree_w1_all <- degree(test_wave1_all)
degree_w1_all <- as.data.frame(degree_w1_all)
# view(degree_w1)
ggplot(degree_w1_all, aes(as.numeric(degree_w1_all), colour = as.numeric(degree_w1_all) )) +
  geom_histogram(binwidth = .5) +
  labs(
    title = "Distribution Degrees Wave 1",
    x = "Distribution of Degrees",
    y = "Count"
  )  +
  ylim(0, 150) +
  theme_bw()
```


### Degree Centrality W2 - Wave 2 (distribution of degrees plot)
```{r}
#degree centrality w2 
degree_w2_all <- degree(test_wave2_all)
degree_w2_all <- as.data.frame(degree_w2_all)
ggplot(degree_w2_all, aes(as.numeric(degree_w2_all), colour = as.numeric(degree_w2_all))) +
  geom_histogram(binwidth = .5) +
  labs(
    title = "Distribution Degrees Wave 2",
    x = "Distribution of Degrees",
    y = "Count"
  ) +
  ylim(0, 150) +
  theme_bw()
```



### Transitivity
Note: Transitivity is not a main focus for this research, as we focus on the effect of gender in collaborations rather than XXX.
```{r}
#TRANSITIVITY -- all of these return "NAN" -- check?
#ALSO: DIRECTED/UNDIRECTED FOR DATA?

# directed: be aware that directed graphs are considered as undirected. CHECK IF TEST_W1 AND 2 ARE DIRECTED OR UNDIRECTED.
## FLAG - ERROR WITH THIS - NOT ABLE TO REALLY USE/VIEW RESULTS
igraph::transitivity(test_wave1_all, type = c("localundirected"), isolates = c("NaN", "zero")) #differences pop out less 
igraph::transitivity(test_wave2_all, type = c("localundirected"), isolates = c("NaN", "zero")) #differences pop out less 

#BETWEENNESS
# directed: be aware that directed graphs are considered as undirected. CHECK IF TEST_W1 AND 2 ARE DIRECTED OR UNDIRECTED.
igraph::transitivity(test_wave1_all, type = c("localundirected"), isolates = c("NaN", "zero"))
igraph::transitivity(test_wave2_all, type = c("localundirected"), isolates = c("NaN", "zero"))

#TRANSITIVITY HISTOGRAMS - 
hist(table(transitivity(test_wave1_all, type = c("localundirected"), isolates = c("NaN", "zero"))))
hist(table(transitivity(test_wave2_all, type = c("localundirected"), isolates = c("NaN", "zero"))))

```



### Dyad and Triad Census (for ref.)
Moving from local to global transitivity 
-   Look at triads for more global transitivity. 
-   Note: Global = number of observed over possible - can identify all transitive triads and all possible triads 
-   Reviewing dyads - then triads. Undirected is less difficult to calculate. 

```{r}
# plot: igraph - XX <- make_graph(y) <- test$nets[1,,] ??
# adj mat: XX <- as_adj_matrix((plot), type = "both", sparse = FALSE) -- adj mat = test_w1 =  test$nets[1,,]


igraph::dyad_census(test_wave1_all) #with plot -- works 
  # Returns: 42 mut, 208 asym, 314571 null 
igraph::dyad_census(test_wave2_all) #with plot -- works
  # Returns: 56 mut, 427 asym, 314338 null 


igraph::triad_census(test_wave1_all) #with plot -- works
  # Returns:  [1] 82915337   163800  33053  93  122   129   87  69  18   0   15   7   5   5   4   0

igraph::triad_census(test_wave2_all) #with plot -- works
  # Returns:   [1] 82731511   335978  44046  155   457   267  161   65   45   1   10   16   12   10   8   2

```


### Triad census, transitivity and triad allegation (for ref.)
-   Now, looking at triad census vs triad allegation. Not essential to research, but interesting to consider.
```{r}
igraph::transitivity(test_wave1_all, type = "global") #with plot
  # Returns: [1] 0.1851266
sna::gtrans(test_all$nets[1,,]) #triad census a different way, but this is with plot - need with adj mat:
  # Returns: [1] 0.1520619

triad_w1_all <- data.frame(sna::triad.census(test_all$nets[1,,])) #save as df, #with adj matrix
transitivity_w1_all <- (3 * triad_w1_all$X300)/(triad_w1_all$X201 + 3 * triad_w1_all$X300) #X300 is variable for transitive triad (the fully closed triad) - we multiply by 3 because there are 3 possible transitive triads
transitivity_w1_all
  # Returns 0 (?)


# Wave 2
igraph::transitivity(test_wave2_all, type = "global")
  # Returns: [1] 0.2018611
sna::gtrans(test_all$nets[2,,]) #triad census a different way 
  # Returns: [1] 0.2127352

triad_w2_all <- data.frame(sna::triad.census(test_all$nets[2,,])) #save as df
transitivity_w2_all <- (3 * triad_w2_all$X300)/(triad_w2_all$X201 + 3 * triad_w2_all$X300) #X300 is variable for transitive triad (the fully closed triad)
# we multiply by 3 because there are 3 possible transitive triads
transitivity_w2_all
  # Returns: [1] 0.375

```






----




# Supplementary Data Manipulation for Cross Gender Collaborations

## Count total collaborations
```{r}
# Total number of collaboration ties in each wave
total_ties_w1_all <- sum(test_all$nets[1,,]) # 292 total ties in Wave 1, same as edges
total_ties_w2_all <- sum(test_all$nets[2,,]) # 542 total ties in Wave 2, same as edges 


# Count total unique collaborations (both outgoing and incoming)
df_ego_all$collab_total_w1 <- rowSums(test_all$nets[1,,]) # + colSums(test$nets[1,,])
df_ego_all$collab_total_w2 <- rowSums(test_all$nets[2,,]) # + colSums(test$nets[2,,])

sum(df_ego_all$collab_total_w1) # 292, confirmation that collaborations = edges 
sum(df_ego_all$collab_total_w2) # 542 
```


## Count cross gender ties in W1 and W2 
Looking at my data - specifically the effect of female (male=0, female=1) over collaborations by RU professors. I also want to compare this effect to controls/statistics (egoX, sameX, etc.). Looking at IF PEOPLE HAVE CROSS GENDER COLLABS.

### Count the number of collaborations that happened between different genders 
```{r}
# Use same count function (to count cross-gender ties) as before! 

#count_xgen <- function(test, gender) {
#  edges <- which(test != 0, arr.ind = TRUE)
#  sum (
#    (gender[edges[,1]] == "female" & gender[edges[,2]] == "male") | 
#      (gender[edges[,1]] == "male" & gender[edges[,2]] == "female") 
#    )
#}

# Wave 1
valid_nodes_w1_all <- which(!is.na(df_ego_all$gender))
adj_w1_clean_all <- test_all$nets[1, valid_nodes_w1_all, valid_nodes_w1_all]
discipline_w1_clean_all <- df_ego_all$gender[valid_nodes_w1_all]

xgen_w1_all <- count_xgen(adj_w1_clean_all, discipline_w1_clean_all)


# Wave 2 -- swap w W1
valid_nodes_w2_all <- which(!is.na(df_ego_all$gender))
adj_w2_clean_all <- test_all$nets[2, valid_nodes_w2_all, valid_nodes_w2_all]
discipline_w2_clean_all <- df_ego_all$gender[valid_nodes_w2_all]

xgen_w2_all <- count_xgen(adj_w2_clean_all, discipline_w2_clean_all)


#make summary table
cross_gender_collabs_table_all <- data.frame(wave = c(1, 2), 
                              cross_gender_ties = c(xgen_w1_all, xgen_w2_all))


print(cross_gender_collabs_table_all)
```
wave    cross_gender_ties
1     	113			
2	      232	



### Count the number of collaborations that happened between the same genders 
Same gender ties 
```{r}
# Use same count function (to count same-gender ties) as before! 

#count_same_gen <- function(test, gender) {
#  edges <- which(test != 0, arr.ind = TRUE)
#  sum (
#    (gender[edges[,1]] == "male" & gender[edges[,2]] == "male") | 
#      (gender[edges[,1]] == "female" & gender[edges[,2]] == "female") 
#    )
#}


# Wave 1
validnodesw1_all <- which(!is.na(df_ego_all$gender))
adjw1clean_all <- test_all$nets[1, validnodesw1_all, validnodesw1_all]
disciplinew1clean_all <- df_ego_all$gender[validnodesw1_all]

same_gen_w1_all <- count_same_gen(adjw1clean_all, disciplinew1clean_all)

# Wave 2 -- swap w W1
validnodesw2_all <- which(!is.na(df_ego_all$gender))
adjw2clean_all <- test_all$nets[2, validnodesw2_all, validnodesw2_all]
disciplinew2clean_all <- df_ego_all$gender[validnodesw2_all]

same_gen_w2_all <- count_same_gen(adjw2clean_all, disciplinew2clean_all)

#make summary table
same_gender_collabs_table_all <- data.frame(wave = c(1, 2), 
                              same_gender_ties = c(same_gen_w1_all, same_gen_w2_all))

print(same_gender_collabs_table_all)

#same gender collaborations: 177 in wave 1, 307 in wave 2. 

```
wave    same_gender_ties
1   	  177			
2	      307	


Confirmation: total number ties/edges/collaborations W1 = 292; 113 = xgen, 177 = same_gen
              total number ties/edges/collaborations W2 = 542; 232 = xgen, 307 = same_gen


## Create column to count the number of cross gender collaborations per professor

### Create function to count if ego has collaborated with another gender professor (if have done xgen collab)
```{r}
# Use the same cross-gender collab function as before 

#has_cross_gender_collab <- function(wave_net, ego_idx, ego_gender, all_genders) {
#  # Get all collaborations for this ego (both outgoing and incoming)
#  outgoing <- which(wave_net[ego_idx, ] != 0)  # who ego collaborates with
#  incoming <- which(wave_net[, ego_idx] != 0)  # who collaborates with ego
#  all_collabs <- unique(c(outgoing, incoming))

#  # If no collaborations, return 0
#  if (length(all_collabs) == 0) {
#    return(0)
#  }
  
#  # Check if any collaborator has different gender
#  collab_genders <- all_genders[all_collabs]
#  has_xgen <- any(collab_genders != ego_gender) # & !is.na(collab_genders))
  
#  return(as.integer(has_xgen))
#}



# Apply function to Wave 1_all
df_ego_all$xgen_w1_all <- sapply(1:nrow(df_ego_all), function(i) {
  if (is.na(df_ego_all$gender[i])) {
    return(NA)
  }
  has_cross_gender_collab(
    wave_net = test_all$nets[1,,],
    ego_idx = i,
    ego_gender = df_ego_all$gender[i],
    all_genders = df_ego_all$gender
  )
})



# Apply to Wave 2
df_ego_all$xgen_w2_all <- sapply(1:nrow(df_ego_all), function(i) {
  if (is.na(df_ego_all$gender[i])) {
    return(NA)
  }
  has_cross_gender_collab(
    wave_net = test_all$nets[2,,],
    ego_idx = i,
    ego_gender = df_ego_all$gender[i],
    all_genders = df_ego_all$gender
  )
})



# View summary
table(df_ego_all$xgen_w1_all, df_ego_all$gender, useNA = "ifany")
 # count number of male and female professors who did and did not participate in x gender collaborations
 # finds: Female: 324 = no xgen, 69 = xgen
        # Male:   336 = no xgen, 56 = xgen
table(df_ego_all$xgen_w2_all, df_ego_all$gender, useNA = "ifany")
 # count number of male and female professors who did and did not participate in x gender collaborations
 # finds: Female: 265 = no xgen, 129 = xgen
        # Male:   280 = no xgen, 112 = xgen


# See how many professors had cross-gender collabs in each wave
summary_table_all <- data.frame(
  wave = c("Wave 1", "Wave 2"),
  profs_with_xgen_all = c(sum(df_ego_all$xgen_w1_all, na.rm = TRUE), 
                      sum(df_ego_all$xgen_w2_all, na.rm = TRUE)),
  profs_without_xgen_all = c(sum(df_ego_all$xgen_w1_all == 0, na.rm = TRUE),
                         sum(df_ego_all$xgen_w2_all == 0, na.rm = TRUE))
)
print(summary_table_all)
```
Radboud Totals: 
wave    profs_with_xgen     profs_without_xgen
1	      125                	660		
2	      241	                545	


### Count/Compare number of ties and number of professors involved in ties -- exclude from this section??!
```{r}
# Wave 1 analysis
# 1. Count professors with at least one cross-gender collab
profs_with_xgen_w1_all <- sum(df_ego_all$xgen_w1_all == 1, na.rm = TRUE) 
profs_with_xgen_w1_all # Counts 125 professors 

# 2. Count total cross-gender ties in network
total_xgen_ties_w1_all <- xgen_w1_all  # from your count_xgen function: 
total_xgen_ties_w1_all #Counts 113 cross-gender ties 



# Same for Wave 2
profs_with_xgen_w2_all <- sum(df_ego_all$xgen_w2_all == 1, na.rm = TRUE)
profs_with_xgen_w2_all # Counts 241 professors 

total_xgen_ties_w2_all <- xgen_w2_all
total_xgen_ties_w2_all # Counts 232 cross-gender ties 

```
It is understandable why the number of professors and ties will vary: it is likely that a collaboration (academic work, article, etc) could have more than one author, such as three authors, with one female and two males, such that then the count of cross gender ties would be 2 (out of the three). Alternatively, if the three authors were all female, there would be 0. If there were just 2 authors, one male and one female, then it would only be 1 cross gender tie. 


### Create column to count the number of cross gender collaborations per professor
```{r}
# Count how many cross-gender collaborations each professor has
df_ego_all$xgen_count_w1_all <- sapply(1:nrow(df_ego_all), function(i) {
  if (is.na(df_ego_all$gender[i])) return(NA)
  
  # Get ego's outgoing and incoming ties
  outgoing <- which(test_all$nets[1,i,] != 0)
  incoming <- which(test_all$nets[1,,i] != 0)
  all_collabs <- unique(c(outgoing, incoming))
  
  # Count how many have different gender
  if (length(all_collabs) == 0) return(0)
  
  sum(df_ego_all$gender[all_collabs] != df_ego_all$gender[i] & 
      !is.na(df_ego_all$gender[all_collabs]))
})

df_ego_all$xgen_count_w2_all <- sapply(1:nrow(df_ego_all), function(i) {
  if (is.na(df_ego_all$gender[i])) return(NA)
  
  outgoing <- which(test_all$nets[2,i,] != 0)
  incoming <- which(test_all$nets[2,,i] != 0)
  all_collabs <- unique(c(outgoing, incoming))
  
  if (length(all_collabs) == 0) return(0)
  
  sum(df_ego_all$gender[all_collabs] != df_ego_all$gender[i] & 
      !is.na(df_ego_all$gender[all_collabs]))
})


# Distribution of cross-gender collaborations
table(df_ego_all$xgen_count_w1_all, useNA = "ifany")
# Distribution in Wave 1: # of professors (bottom) with # of xgen collabs (top)
#   0    1    2    3    4    5    6 <NA> 
#  662   80   30   11   2    1    1    7 


table(df_ego_all$xgen_count_w2_all, useNA = "ifany")
# Distribution in Wave 1: # of professors (bottom) with # of xgen collabs (top)
#    0    1    2    3    4    5    7    8  <NA> 
#  546  136   68   26    4    5    1    1    7

# Summary statistics
summary(df_ego_all$xgen_count_w1_all)
summary(df_ego_all$xgen_count_w2_all)


# MAKE COLUMN WITH THE NEW X GENDER COLLABORATIONS FORMED SINCE WAVE 1
df_ego_all$xgen_count_new_all <- (df_ego_all$xgen_count_w2_all) - (df_ego_all$xgen_count_w1_all)

```




----




# RSiena Analysis


### ansM1
``` {r}
mydata_all = sienaDataCreate(net_all, female_all)
myeff_all = getEffects(mydata_all)
myeff_all = includeEffects(myeff_all, isolateNet, inPop.c) 
myeff_all = includeEffects(myeff_all, egoX, interaction1 = "female_all") # Independent variable under investigation


# ONLY LOOKING AT FEMALE EFFECT FIRST - look at this in ansM3
# myeff = includeEffects(myeff, egoX, interaction1 = "polsci") # Control for sociology vs political science departments

# myeff = includeEffects(myeff, egoX, altX, diffX, interaction1 = "female") -- removing altX and diffX because they didn't help initial model at all! 


#myAlgorithm = sienaAlgorithmCreate(
#    projname = "finalpaper_all", 
#    maxDegree = c(net_all = 50))

#ansM1_all = siena07(
#    myAlgorithm, 
#    data = mydata_all, 
#    effects = myeff_all,
#    returnDeps = TRUE
#)

ansM1_all

```















































# GOODNESS OF FIT FOR ALL UNI'S

```{r}
GeodesicDistribution <- function(i, data, sims, period, groupName, varName, levls = c(1:5, Inf), cumulative = TRUE,
    ...) {
    x <- networkExtraction(i, data, sims, period, groupName, varName)
    require(sna)
    a <- sna::geodist(symmetrize(x))$gdist
    if (cumulative) {
        gdi <- sapply(levls, function(i) {
            sum(a <= i)
        })
    } else {
        gdi <- sapply(levls, function(i) {
            sum(a == i)
        })
    }
    names(gdi) <- as.character(levls)
    gdi
}

# The following function is taken from the help page for sienaTest -- use "ansM2"

#testall_all <- function(ansM1_all) {
#    for (i in which(ansM1_all$test_all)) {
#        sct <- score.Test(ansM1_all, i)
#        cat(ansM1_all$requestedEffects$effectName[i], "\n")
#        print(sct)
#    }
#    invisible(score.Test(ansM1_all))
#}
```


# First GOF model  

```{r}
#gofi_all <- sienaGOF(ansM1_all, IndegreeDistribution, verbose = FALSE, join = TRUE, varName = "net_all")
##gofi_all
#plot(gofi_all)

# variable name from example = net
# x-axis = indegree 
# y-axis = frequency (plotting the people with 0 in-degrees)

```


# TBD: outdegree distribution

```{r}

#gofi_all2 <- sienaGOF(ansM1_all, OutdegreeDistribution, verbose = FALSE, join = TRUE, varName = "gender")

# gofi1 <- sienaGOF(ansM1, OutdegreeDistribution, verbose = FALSE, join = TRUE, levls = c(0:10, 15, 20), varname = "net")

```



# RELATIVE INFLUENCE 

```{r}
#RI_all <- RSiena:::sienaRI(data = mydata_all, ans = ansM1_all)

#class(RI_all)

#RSiena:::plot.sienaRI(RI_all, addPieChart = TRUE)
```


```{r}
```


```{r}
```

























